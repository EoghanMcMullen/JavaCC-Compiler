/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. basicL.jj */
/*@egen*/options 
{
	IGNORE_CASE = true;
	JAVA_UNICODE_ESCAPE = true;
	             
	                         
	               
}
PARSER_BEGIN (basicL)
	
import java.io.*;
import java.util.*;

class basicL/*@bgen(jjtree)*/implements basicLTreeConstants/*@egen*/
{/*@bgen(jjtree)*/
  protected static JJTbasicLState jjtree = new JJTbasicLState();

/*@egen*/
	public static void main(String[] args) throws ParseException, FileNotFoundException
	{

			basicL parser = new basicL(System.in);
            SimpleNode program = parser.program();
			
			System.out.println("------------------AST----------------------");

			program.dump(" ");
			System.out.println();
			
			System.out.println();
			
			BasicLSemanticVisitor visitor = new BasicLSemanticVisitor();
			program.jjtAccept(visitor, null);
    }
}
PARSER_END (basicL)

TOKEN_MGR_DECLS :
{
  static int commentNesting = 0;
}

SKIP : 
{ 						
	  " "
	| "\t"
	| "\r"
	| "\n"
	| "\f"
}

SKIP : 
{  						
	< "--" (~["\r", "\n"]) *>
	|"/*" { commentNesting++; } : IN_COMMENT
}

<IN_COMMENT> SKIP : 
{			
	"/*" { commentNesting++; }
	| "*/" { commentNesting--;
	if (commentNesting == 0)
		SwitchTo(DEFAULT);
		}
	| <~[]>
}

TOKEN : 
{						
	 < PLUS : "+" >
	| < MINUS : "-" >
	| < MULTIPLY : "*" >
	| < DIVIDE : "/" >
	| < EQUALS : "=" >
	| < NOT_EQUAL : "!=" >
	| < LESS_THAN : "< " >
	| < GREATER_THAN : " >" >
	| < LESS_THAN_EQUAL : "<=" >
	| < GREATER_THAN_EQUAL : " >=" >
	| < LEFT_PARENTHESES : "(" >
	| < RIGHT_PARENTHESES : ")" >
	| < COMMA : "," >
	| < SEMI_COLON : ";" >
	| < COLON : ":" > 
	| < ASSIGN : ":=" >
}

TOKEN: 
{							
	< AND : "and" >
    | < BOOL : "bool" >
	| < CONST : "const" >
	| < DO : "do" >
	| < ELSE : "else" >
	| < FALSE : "false" >
	| < IF : "if" >
	| < INT : "int" >
	| < MAIN : "main" >
	| < NOT : "not" >
	| < OR : "or" >
	| < RETURN : "return" >
	| < THEN : "then" >
	| < TRUE : "true" >
	| < VAR : "var" >
	| < VOID : "void" >
	| < WHILE : "while" >
	| < BEGIN : "begin" >
	| < END : "end" >
}

TOKEN : // Numbers 
{
    < NUMBER : (<DIGIT>)+ >
    | < #DIGIT : ["0" - "9"] >
}

TOKEN : // Identifiers 
{
    < ID : <LETTER> (<LETTER> | <DIGIT> | "_")* >
    | < #LETTER : ["a" - "z"] | ["A" - "Z"] >
}

//=============================================
//=======GRAMMER===============================

SimpleNode program()         : {/*@bgen(jjtree) Program */
  ASTProgram jjtn000 = new ASTProgram(JJTPROGRAM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} 
{/*@bgen(jjtree) Program */
        try {
/*@egen*/
	(
		(decl())*
		(function())*
		main_prog()
	)<EOF>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{return jjtn000;}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void decl(): {} 
{
	(var_decl() | const_decl())
}

void var_decl()         : {/*@bgen(jjtree) VarDecl */
  ASTVarDecl jjtn000 = new ASTVarDecl(JJTVARDECL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} 
{/*@bgen(jjtree) VarDecl */
        try {
/*@egen*/
	<VAR> ident_list()<COLON>type()(<COMMA>ident_list()<COLON>type())*<SEMI_COLON>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void const_decl()            : {/*@bgen(jjtree) const_decl */
  ASTconst_decl jjtn000 = new ASTconst_decl(JJTCONST_DECL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) const_decl */
        try {
/*@egen*/
	<CONST>id()<COLON>type() <EQUALS> expression()(<COMMA>id()<COLON>type() <EQUALS> expression())*<SEMI_COLON>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void function()          : {/*@bgen(jjtree) Function */
  ASTFunction jjtn000 = new ASTFunction(JJTFUNCTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} 
{/*@bgen(jjtree) Function */
        try {
/*@egen*/
	type() id() <LEFT_PARENTHESES> param_list() <RIGHT_PARENTHESES>
	<BEGIN>
	(decl())*
	( statement() <SEMI_COLON> )*
	<RETURN>(expression()|{})<SEMI_COLON>
	<END>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}


void param_list()            : {/*@bgen(jjtree) param_list */
  ASTparam_list jjtn000 = new ASTparam_list(JJTPARAM_LIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} 
{/*@bgen(jjtree) param_list */
        try {
/*@egen*/
	(id()<COLON>type()(<COMMA>id()<COLON>type())* |/*@bgen(jjtree)*/
                                                        {
                                                          jjtree.closeNodeScope(jjtn000, true);
                                                          jjtc000 = false;
                                                        }
/*@egen*/ {})/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void type()       : {/*@bgen(jjtree) Type */
  ASTType jjtn000 = new ASTType(JJTTYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Type */
                try {
/*@egen*/
		<INT>/*@bgen(jjtree)*/
                                {
                                  jjtree.closeNodeScope(jjtn000, true);
                                  jjtc000 = false;
                                }
/*@egen*/		{ jjtn000.value=token; }
    | 	<BOOL>/*@bgen(jjtree)*/
                        {
                          jjtree.closeNodeScope(jjtn000, true);
                          jjtc000 = false;
                        }
/*@egen*/ 		{ jjtn000.value=token; }
    | 	<VOID>/*@bgen(jjtree)*/
                        {
                          jjtree.closeNodeScope(jjtn000, true);
                          jjtc000 = false;
                        }
/*@egen*/ 		{ jjtn000.value=token; }/*@bgen(jjtree)*/
                } finally {
                  if (jjtc000) {
                    jjtree.closeNodeScope(jjtn000, true);
                  }
                }
/*@egen*/
}

void main_prog()           : {/*@bgen(jjtree) main_prog */
  ASTmain_prog jjtn000 = new ASTmain_prog(JJTMAIN_PROG);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} 
{/*@bgen(jjtree) main_prog */
        try {
/*@egen*/
	<MAIN>
	<BEGIN>
	( decl() )*
	( statement() <SEMI_COLON> )*
	<END>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void statement(): {} 
{
	id()(<ASSIGN>expression()|<LEFT_PARENTHESES>arg_list()/*@bgen(jjtree) FunctionCall */
                                                              {
                                                                ASTFunctionCall jjtn001 = new ASTFunctionCall(JJTFUNCTIONCALL);
                                                                boolean jjtc001 = true;
                                                                jjtree.openNodeScope(jjtn001);
                                                              }
                                                              try {
/*@egen*/<RIGHT_PARENTHESES>/*@bgen(jjtree)*/
                                                              } finally {
                                                                if (jjtc001) {
                                                                  jjtree.closeNodeScope(jjtn001, true);
                                                                }
                                                              }
/*@egen*/             )
	|<BEGIN>(statement()<SEMI_COLON>)*<END>
	|<IF>condition()<THEN>statement()<SEMI_COLON><ELSE>statement()
	|<WHILE>condition()<DO>statement()
	|{}
}

void expression(): {} 
{ 
	id()(<LEFT_PARENTHESES>arg_list()<RIGHT_PARENTHESES>|(mathematical_symbols()))
	|	fragment() mathematical_symbols()
}

void arg_list() :{} 
{
	(id()(<COMMA>id())* | {})
}

void fragment(): {} 
{
		number()
	|	<TRUE> 
	| 	<FALSE> 
	|	<PLUS>|<MINUS>fragment()
 	|	<LEFT_PARENTHESES>expression()<RIGHT_PARENTHESES>
}

void condition()           : {/*@bgen(jjtree) Condition */
  ASTCondition jjtn000 = new ASTCondition(JJTCONDITION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} 
{/*@bgen(jjtree) Condition */
        try {
/*@egen*/
	<NOT>condition()
	|LOOKAHEAD(2)<LEFT_PARENTHESES> condition() <RIGHT_PARENTHESES> booleanOperators()
	|expression() booleanOperators()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void ident_list()        : {/*@bgen(jjtree) IdList */
  ASTIdList jjtn000 = new ASTIdList(JJTIDLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} 
{/*@bgen(jjtree) IdList */
        try {
/*@egen*/
	id()(<COMMA>id())*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}


void mathematical_symbols(): {} 
{
	<PLUS> expression() 
	|<MINUS> expression()
	|<MULTIPLY> expression() 
	|<DIVIDE> expression() 
	|{}
}

void booleanOperators() : {} 
{
	<EQUALS> condition()
	|<NOT> condition()
	|<NOT_EQUAL> condition()
	|<GREATER_THAN> condition()
	|<GREATER_THAN_EQUAL> condition()
	|<LESS_THAN_EQUAL> condition()
	|<LESS_THAN> condition()
	|<AND> condition()
	|<OR> condition()
	|{}
}

void number()        : {/*@bgen(jjtree) Number */
  ASTNumber jjtn000 = new ASTNumber(JJTNUMBER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} 
{/*@bgen(jjtree) Number */
        try {
/*@egen*/
	<NUMBER>/*@bgen(jjtree)*/
                 {
                   jjtree.closeNodeScope(jjtn000, true);
                   jjtc000 = false;
                 }
/*@egen*/ { jjtn000.value = token; }/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void id()    : {/*@bgen(jjtree) Id */
                 ASTId jjtn000 = new ASTId(JJTID);
                 boolean jjtc000 = true;
                 jjtree.openNodeScope(jjtn000);
/*@egen*/ Token token; } 
{/*@bgen(jjtree) Id */
        try {
/*@egen*/
	token = <ID>/*@bgen(jjtree)*/
                     {
                       jjtree.closeNodeScope(jjtn000, true);
                       jjtc000 = false;
                     }
/*@egen*/ { jjtn000.value = token; }/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}